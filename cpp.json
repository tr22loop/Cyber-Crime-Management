{
	"default template": {
		"prefix": "cpp",
		"body": [
			"#include <bits/stdc++.h>\r",
			"using namespace std;\r",
			"\r",
			"double eps = 1e-9;\r",
			"double pi = acos(-1);\r",
			"\r",
			"int fx[8] = {1, -1, 0, 0, 1, -1, -1, 1};\r",
			"int fy[8] = {0, 0, 1, -1, 1, -1, 1, -1};\r",
			"\r",
			"// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r",
			"\r",
			"#define fast_io ios_base::sync_with_stdio(false); cin.tie(0);\r",
			"#define ll long long\r",
			"#define ull unsigned long long\r",
			"#define en \"\\n\"\r",
			"#define ff first\r",
			"#define ss second\r",
			"#define sp(x) fixed << setprecision(x)\r",
			"#define VECT(v)  vector<int>v\r",
			"#define SCAN(v)  int temp; for(int i=0; i<n; i++) {cin>>temp; v.push_back(temp);}\r",
			"#define PRINT(v) for(int i = 0; i < v.size(); i++) cout << v[i] << \" \"; cout << en;\r",
			"#define SORT(v)  sort(v.begin(), v.end());\r",
			"#define RSORT(v) sort(v.begin(), v.end(), greater<int>())\r",
			"#define CASEP(v) cout<<\"Case \"<<tc<<\": \"<<v<<\"\\n\"\r",
			"#define DEBUG(v) cout << v << \" \"; cout << en;\r",
			"#define MIN(a, b) a < b ? a : b\r",
			"#define MAX(a, b) a > b ? a : b\r",
			"#define all(v) v.begin(), v.end()",
			"#define mem(a, b) memset(a, b, sizeof(a))\r",
			"#define valid(nx, ny, row, col) nx >= 0 && nx < row && ny >= 0 && ny < col\r",
			"#define pii pair <int, int>\r",
			"#define inf int(2e9)\r",
			"#define mod int(1e9 + 7)\r",
			"\r",
			"int main(void)\r",
			"{\r",
			"\t#ifndef ONLINE_JUDGE\r",
			"\t\tfreopen(\"in.txt\", \"r\", stdin);\r",
			"\t\tfreopen(\"out.txt\", \"w\", stdout);\r",
			"\t#endif\r",
			"\r",
			"\tfast_io\r",
			"\r",
			"\treturn 0;\r",
			"}"
		],
		"description": "cpp template"
	},
	"Test Cases": {
		"prefix": "tcp",
		"body": [
			"int t;\r",
			"cin >> t;\r",
			"for(int tc = 1; tc <= t; tc++)\r",
			"{\r",
			"\r",
			"}"
		],
		"description": "description for Test Cases"
	},
	"BigMod": {
		"prefix": "bigmod",
		"body": [
			"ll bigMod(ll a, ll b, ll c)\r",
			"{\r",
			"\tll rem = a % c, ans = 1 % c;\r",
			"\twhile(b > 0)\r",
			"\t{\r",
			"\t\tif(b % 2)\r",
			"\t\t\tans = (ans * rem) % c;\r",
			"\r",
			"\t\trem = (rem * rem) % c;\r",
			"\r",
			"\t\tb /= 2;\r",
			"\t}\r",
			"\treturn ans;\r",
			"}"
		],
		"description": "description for BigMod"
	},
	"BigPow": {
		"prefix": "bigpow",
		"body": [
			"ll bigPow(ll a, ll b)\r",
			"{\r",
			"\tll ans = 1;\r",
			"\twhile(b--)\r",
			"\t{\r",
			"\t\tans = ans * a;\r",
			"\t}\r",
			"\treturn ans;\r",
			"}"
		],
		"description": "description for BigPow"
	},
	"GCD": {
		"prefix": "gcd",
		"body": [
			"ll gcd(ll a, ll b)\r",
			"{\r",
			"\tif(b == 0)\r",
			"\t\treturn a;\r",
			"\telse\r",
			"\t\treturn gcd(b, a % b);\t\r",
			"}"
		],
		"description": "description for GCD"
	},
	"LCM": {
		"prefix": "lcm",
		"body": [
			"ll lcm(ll a, ll b)\r",
			"{\r",
			"\treturn (a/gcd(a, b)) * b;\r",
			"}"
		],
		"description": "description for LCM"
	},
	"Number of Divisors": {
		"prefix": "nod",
		"body": [
			"const int lim = \r",
			"\r",
			"int num[lim + 5] = {};\r",
			"\r",
			"void NOD()\r",
			"{\r",
			"\tfor(int i = 1; i <= lim; i++)\r",
			"\t{\r",
			"\t\tfor(int j = i; j <= lim; j += i)\r",
			"\t\t{\r",
			"\t\t\tnum[j]++;\r",
			"\t\t}\r",
			"\t}\r",
			"}"
		],
		"description": "Number of divisors"
	},
	"Prime Sieve": {
		"prefix": "primesieve",
		"body": [
			"const int lim = \r",
			"\r",
			"bool prime[lim + 10];\r",
			"vector <int> pNum;\r",
			"\r",
			"void sieve()\r",
			"{\r",
			"\tmem(prime, true);\r",
			"    prime[0] = prime[1] = false;\r",
			"\tfor(int i = 2; (ll)i * i <= lim; i++)\r",
			"\t{\r",
			"\t\tif(prime[i])\r",
			"\t\t{\r",
			"\t\t\tfor(int j = i * i; j <= lim; j += i)\r",
			"\t\t\t{\r",
			"\t\t\t\tprime[j] = false;\r",
			"\t\t\t}\r",
			"\t\t}\r",
			"\t}\r",
			"\r",
			"\tfor(int i = 2; i <= lim; i++)\r",
			"\t{\r",
			"\t\tif(prime[i])\r",
			"\t\t\tpNum.push_back(i);\r",
			"\t}\r",
			"}"
		],
		"description": "description for Prime Sieve"
	},
	"Sum of Divisors": {
		"prefix": "sod",
		"body": [
			"const int lim = \r",
			"\r",
			"int num[lim + 5];\r",
			"\r",
			"void SOD()\r",
			"{\r",
			"\tfor(int i = 1; i <= lim; i++)\r",
			"\t{\r",
			"\t\tfor(int j = i; j <= lim; j += i)\r",
			"\t\t{\r",
			"\t\t\tnum[j] += i;\r",
			"\t\t}\r",
			"\t}\r",
			"}"
		],
		"description": "description for Sum of Divisors"
	},
	"Primefactor O(n x n)": {
		"prefix": "primefactor",
		"body": [
			"const int lim = \r",
			"\r",
			"bool prime[lim + 10];\r",
			"vector <int> pNum, pf, times;\r",
			"\r",
			"void sieve()\r",
			"{\r",
			"\tmem(prime, true, sizeof(prime));\r",
			"    prime[0] = prime[1] = false;\r",
			"\tfor(int i = 2; (ll)i * i <= lim; i++)\r",
			"\t{\r",
			"\t\tif(prime[i])\r",
			"\t\t{\r",
			"\t\t\tfor(int j = i * i; j <= lim; j += i)\r",
			"\t\t\t{\r",
			"\t\t\t\tprime[j] = false;\r",
			"\t\t\t}\r",
			"\t\t}\r",
			"\t}\r",
			"\r",
			"\tfor(int i = 2; i <= lim; i++)\r",
			"\t{\r",
			"\t\tif(prime[i])\r",
			"\t\t\tpNum.push_back(i);\r",
			"\t}\r",
			"}\r",
			"\r",
			"void fact(ll n)\r",
			"{\r",
			"\tfor(int i = 0; i < pNum.size(); i++)\r",
			"\t{\r",
			"\t\tll p = pNum[i];\r",
			"\r",
			"\t\tif(p * p > n)\r",
			"\t\t\tbreak;\r",
			"\r",
			"\t\tint cnt = 0;\r",
			"\t\tif(n % p == 0)\r",
			"\t\t{\r",
			"\t\t\twhile(n % p == 0)\r",
			"\t\t\t{\r",
			"\t\t\t\tn /= p;\r",
			"\t\t\t\tcnt++;\r",
			"\t\t\t}\r",
			"\t\t\tpf.push_back(p);\r",
			"\t\t\ttimes.push_back(cnt);\r",
			"\t\t}\r",
			"\t}\r",
			"\tif(n > 1)\r",
			"\t{\r",
			"\t\tpf.push_back(n);\r",
			"\t\ttimes.push_back(1);\r",
			"\t}\r",
			"}"
		],
		"description": "description for Primefactor O(n x n)"
	},
	"DSU": {
		"prefix": "dsu",
		"body": [
			"const int lim = \r",
			"int parent[lim], len[lim];\r",
			"\r",
			"void make_set(int n)\r",
			"{\r",
			"    for(int i = 0; i <= n; i++)\r",
			"    {\r",
			"        parent[i] = i;\r",
			"        len[i] = 1;\r",
			"    }\r",
			"}\r",
			"\r",
			"int find_set(int v)\r",
			"{\r",
			"    if(parent[v] == v)\r",
			"        return v;\r",
			"\r",
			"    return parent[v] = find_set(parent[v]);\r",
			"}\r",
			"\r",
			"void union_set(int a, int b)\r",
			"{\r",
			"    a = find_set(a);\r",
			"    b = find_set(b);\r",
			"\r",
			"    if(a != b)\r",
			"    {\r",
			"        if(len[a] < len[b])\r",
			"            swap(a, b);\r",
			"\r",
			"        parent[b] = a;\r",
			"        len[a] += len[b];\r",
			"    }\r",
			"}"
		],
		"description": "description for DSU"
	}
}